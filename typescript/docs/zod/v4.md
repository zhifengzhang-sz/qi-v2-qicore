# Zod v4 Migration Experience

**Real-world experience migrating from mixed Zod versions to Zod v4.1.5 in QiCore Foundation**

## Context

QiCore Foundation's `@qi/core/config` module uses Zod for schema validation in configuration management. During development, we encountered significant type issues when upgrading to Zod v4, particularly with `validateWith()` and `validateConfig()` functions.

## The Problem

### Original Issue
Functions expecting Zod schemas couldn't accept `ZodObject` instances due to incorrect typing:

```typescript
// This failed in our original implementation
const AppSchema = z.object({
  port: z.coerce.number().default(3000),
  debug: z.coerce.boolean().default(false)
})

// TypeError: validateWith expected interface with encode/decode methods
validateWith(AppSchema) // ❌ Failed
```

### Root Cause
Our code was using deprecated Zod v3 patterns:
- `ZodTypeAny` (deprecated in v4)
- Mixed versions across packages (3.25.76, 4.0.5, 4.1.5)
- Incorrect type constraints expecting encode/decode interfaces

## The Solution

### 1. Version Standardization
**Critical**: Use consistent Zod version across all packages:

```json
{
  "dependencies": {
    "zod": "^4.1.5"
  }
}
```

**Verify with:**
```bash
bun ls zod
# Should show single version: zod@4.1.5
```

### 2. Type System Migration

**Before (Zod v3 patterns):**
```typescript
import { z, ZodTypeAny } from 'zod'

// ❌ ZodTypeAny doesn't exist in v4
validateWith(schema: ZodTypeAny): ConfigBuilder
validateConfig<T>(config: Config, schema: ZodTypeAny): Result<T, QiError>
```

**After (Zod v4 patterns):**
```typescript
import { z, ZodType } from 'zod'

// ✅ ZodType is the correct v4 type
validateWith(schema: z.ZodType): ConfigBuilder
validateConfig<T>(config: Config, schema: z.ZodType): Result<T, QiError>
```

### 3. Schema Definition Patterns

**Zod v4 schema patterns work seamlessly:**

```typescript
// Basic schema
const ConfigSchema = z.object({
  port: z.coerce.number().default(3000),
  host: z.string().default('localhost'),
  debug: z.coerce.boolean().default(false)
})

// Nested schema
const DatabaseConfig = z.object({
  host: z.string(),
  port: z.coerce.number().default(5432),
  ssl: z.boolean().default(false)
})

const AppSchema = z.object({
  server: ConfigSchema,
  database: DatabaseConfig,
  features: z.array(z.string()).default([])
})

// Usage - works with our fixed types
const configResult = await ConfigBuilder
  .fromEnv('APP')
  .validateWith(AppSchema)
  .build()
```

### 4. Error Handling Integration

Zod v4 validation integrates cleanly with QiCore's Result<T> patterns:

```typescript
// Our validateConfig function properly handles Zod v4 errors
const validateConfig = <T>(
  config: Config, 
  schema: z.ZodType<T>
): Result<T, QiError> => {
  try {
    const validated = schema.parse(config.toObject())
    return success(validated)
  } catch (error) {
    if (error instanceof z.ZodError) {
      return failure(new QiError(
        'VALIDATION_ERROR',
        `Configuration validation failed: ${error.message}`,
        { issues: error.issues }
      ))
    }
    return failure(new QiError('UNKNOWN_ERROR', 'Validation failed'))
  }
}
```

## Key Zod v4 Insights

### 1. Simplified Type System
- `ZodTypeAny` → `ZodType` 
- `ZodType<Output, Input>` → `ZodType<Output = unknown, Input = unknown>`
- More predictable type inference

### 2. Better Default Handling
```typescript
// v4 handles defaults more consistently
const schema = z.object({
  port: z.coerce.number().default(3000),
  enabled: z.boolean().default(true)
})

// Parsing with missing values works correctly
const result = schema.parse({}) // { port: 3000, enabled: true }
```

### 3. Improved Coercion
```typescript
// String to number coercion is more reliable
const PortSchema = z.coerce.number()

PortSchema.parse("3000") // 3000
PortSchema.parse(3000)   // 3000
```

## Common Migration Patterns

### Configuration with Environment Variables
```typescript
const ServerSchema = z.object({
  port: z.coerce.number().default(3000),
  host: z.string().default('localhost'),
  cors: z.object({
    origin: z.union([z.string(), z.array(z.string())]).default('*'),
    credentials: z.coerce.boolean().default(false)
  }).default({})
})

// Load from environment with validation
const configResult = await ConfigBuilder
  .fromEnv('SERVER')
  .validateWith(ServerSchema)
  .build()
```

### JSON Schema Integration
We also use `zod-from-json-schema` for dynamic schema loading:

```typescript
import { zodFromJsonSchema } from 'zod-from-json-schema'

// Convert JSON Schema to Zod v4 schema
const jsonSchema = {
  type: 'object',
  properties: {
    name: { type: 'string' },
    age: { type: 'number', minimum: 0 }
  },
  required: ['name']
}

const zodSchema = zodFromJsonSchema(jsonSchema)
// Returns proper ZodType compatible with our functions
```

## Build System Considerations

### TypeScript Configuration
Ensure your tsconfig.json supports Zod v4:

```json
{
  "compilerOptions": {
    "target": "ES2023",
    "lib": ["ES2023"],
    "strict": true,
    "moduleResolution": "bundler"
  }
}
```

### Declaration Bundling
When bundling types, avoid name collisions:

```bash
# Use --export-referenced-types false to avoid conflicts
dts-bundle-generator -o dist/index.d.ts temp/index.d.ts --export-referenced-types false
```

## Testing Patterns

### Property-Based Testing with Zod v4
```typescript
import { test, expect } from 'vitest'
import { z } from 'zod'

const ConfigSchema = z.object({
  port: z.coerce.number().min(1000).max(65535),
  debug: z.coerce.boolean()
})

test('config validation handles various input types', () => {
  // String inputs (environment variables)
  const result1 = ConfigSchema.parse({ port: "3000", debug: "true" })
  expect(result1).toEqual({ port: 3000, debug: true })
  
  // Mixed inputs
  const result2 = ConfigSchema.parse({ port: 8080, debug: "false" })
  expect(result2).toEqual({ port: 8080, debug: false })
})
```

## Lessons Learned

1. **Version Consistency is Critical**: Mixed Zod versions cause mysterious type errors
2. **Migration Strategy**: Update types first, then test thoroughly
3. **Documentation Matters**: Zod v4 docs are the authoritative source, not v3
4. **Integration Testing**: Verify schema validation works with your actual data patterns
5. **Error Messages**: Zod v4 provides better error messages for debugging

## Working Examples

See these files for complete working examples:
- `/lib/core/src/config.ts` - Main validation functions
- `/lib/core/tests/config.test.ts` - Comprehensive test cases
- `/app/config-example/` - Real-world usage patterns

## Quick Reference

```typescript
// ✅ Correct Zod v4 imports
import { z, ZodType, ZodError } from 'zod'

// ✅ Correct type annotations
function validate<T>(schema: z.ZodType<T>): T

// ✅ Schema definition
const MySchema = z.object({
  field: z.string().default('value')
})

// ✅ Error handling
try {
  const result = MySchema.parse(data)
} catch (error) {
  if (error instanceof z.ZodError) {
    // Handle validation errors
  }
}
```

This migration experience shows that Zod v4 simplifies the type system while providing better runtime validation - the key is understanding the breaking changes and updating code accordingly.